-- Quest tracking system for campaigns
-- Quests are auto-generated by the AI DM during gameplay

-- Main quests table
CREATE TABLE quests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  campaign_id UUID NOT NULL REFERENCES campaigns(id) ON DELETE CASCADE,

  title TEXT NOT NULL,
  description TEXT,
  quest_giver TEXT,  -- NPC name who gave the quest

  status TEXT NOT NULL DEFAULT 'active',  -- 'active', 'completed', 'failed'
  priority INTEGER DEFAULT 0,  -- For sorting (higher = more important)

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_quests_campaign ON quests(campaign_id);
CREATE INDEX idx_quests_status ON quests(status);

-- Quest objectives (sub-tasks)
CREATE TABLE quest_objectives (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quest_id UUID NOT NULL REFERENCES quests(id) ON DELETE CASCADE,

  description TEXT NOT NULL,
  is_completed BOOLEAN DEFAULT FALSE,
  sort_order INTEGER DEFAULT 0,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_quest_objectives_quest ON quest_objectives(quest_id);

-- Updated_at trigger for quests
CREATE OR REPLACE FUNCTION update_quest_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER quests_updated_at
  BEFORE UPDATE ON quests
  FOR EACH ROW
  EXECUTE FUNCTION update_quest_updated_at();

-- RLS Policies

-- Enable RLS
ALTER TABLE quests ENABLE ROW LEVEL SECURITY;
ALTER TABLE quest_objectives ENABLE ROW LEVEL SECURITY;

-- Campaign members can read quests
CREATE POLICY "Campaign members can read quests"
  ON quests FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM campaign_members
      WHERE campaign_members.campaign_id = quests.campaign_id
      AND campaign_members.user_id = auth.uid()
    )
  );

-- Host can create quests (AI DM operates as host)
CREATE POLICY "Host can create quests"
  ON quests FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM campaign_members
      WHERE campaign_members.campaign_id = quests.campaign_id
      AND campaign_members.user_id = auth.uid()
      AND campaign_members.role = 'host'
    )
  );

-- Host can update quests
CREATE POLICY "Host can update quests"
  ON quests FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM campaign_members
      WHERE campaign_members.campaign_id = quests.campaign_id
      AND campaign_members.user_id = auth.uid()
      AND campaign_members.role = 'host'
    )
  );

-- Host can delete quests
CREATE POLICY "Host can delete quests"
  ON quests FOR DELETE
  USING (
    EXISTS (
      SELECT 1 FROM campaign_members
      WHERE campaign_members.campaign_id = quests.campaign_id
      AND campaign_members.user_id = auth.uid()
      AND campaign_members.role = 'host'
    )
  );

-- Quest objectives policies (inherit from parent quest)
CREATE POLICY "Can read quest objectives if can read quest"
  ON quest_objectives FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM quests
      WHERE quests.id = quest_objectives.quest_id
      AND EXISTS (
        SELECT 1 FROM campaign_members
        WHERE campaign_members.campaign_id = quests.campaign_id
        AND campaign_members.user_id = auth.uid()
      )
    )
  );

CREATE POLICY "Host can manage quest objectives"
  ON quest_objectives FOR ALL
  USING (
    EXISTS (
      SELECT 1 FROM quests
      WHERE quests.id = quest_objectives.quest_id
      AND EXISTS (
        SELECT 1 FROM campaign_members
        WHERE campaign_members.campaign_id = quests.campaign_id
        AND campaign_members.user_id = auth.uid()
        AND campaign_members.role = 'host'
      )
    )
  );

-- Enable realtime for quests
ALTER PUBLICATION supabase_realtime ADD TABLE quests;
ALTER PUBLICATION supabase_realtime ADD TABLE quest_objectives;
